{
	"allQuestions": [],
	"interviewQuestions": [{
		"id": 76,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "Advantages of Kotlin?",
		"referenceLink": "https://sagaratechnology.medium.com/what-are-the-benefits-of-kotlin-d7fdcd1cfc0",
		"answer": "<p><strong>The Benefit of Kotlin</strong></p><ul><li><strong>Compact code</strong>: Kotlin is an OOPs-based programming language with code lines that may be reduced by up to 40% when compared to Java, making it an excellent choice for software development.</li><li><strong>Open Source</strong>: Kotlin for Android is open-source and uses the JVM to combine the benefits of OOPs and functional programming.</li><li><strong>Simple Language</strong>: When working with Kotlin, compiling the code is simple, resulting in improved performance for&nbsp;<a href='https://www.interviewbit.com/android-interview-questions/' rel='noopener noreferrer' target='_blank'>Android development</a>. It also explains which types of data functions can be used throughout the code.</li><li><strong>High number of extensions</strong>: Without modifying the code, Kotlin may support a variety of extension functions. It aids developers in making existing code more appealing and wonderful.</li><li><strong>Full Java Interoperability</strong>: Java code can utilize Kotlin code, and Kotlin code can use Java code. So, if you&#39;re familiar with OOPS programming, switching to Kotlin development is simple. Also, if there are any Java-based applications, they can be used with Kotlin&#39;s environment.</li><li><strong>Smart Cast</strong>: Smart casting is a technique that reduces the cost of an application while also improving its speed and performance. It uses typecasting or immutable data to manage the efficiency of programming. This technique is supported by Kotlin.</li><li><strong>Low Learning Curve</strong>: Kotlin is preferred by businesses due to its low adoption cost. Most significantly, it is simple for developers to learn, especially if they have programming experience.</li></ul></p>"
	}, {
		"id": 77,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "What are the various data types available in Kotlin?",
		"referenceLink": "",
		"answer": "<p>Kotlin Data Types:</p><ul><li>Boolean</li><li>Character</li><li>Number<ul><li>Byte</li><li>Short</li><li>Int</li><li>Long</li><li>Double</li><li>Float</li></ul></li><li>String</li><li>Array</li></ul>"
	}, {
		"id": 78,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "How are variables declared in Kotlin?",
		"referenceLink": "https://www.interviewbit.com/kotlin-interview-questions/",
		"answer": "<p>Every variable in Kotlin must be declared before it can be used. An attempt to use a variable without declaring it results in a syntax error. The type of data you are authorised to put in the memory address is determined by the variable type declaration. The type of variable can be determined from the initialised value in the case of local variables.</p><p>For example,</p><p><strong><em><code>var site=&quot;interviewbit&quot;</code></em></strong></p><p>The above code declares a variable &ldquo;site&rdquo; of type String because the value with which the variable is initialised is a String.</p>"
	}, {
		"id": 79,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "What are the different types of variables in Kotlin?",
		"referenceLink": "https://www.interviewbit.com/kotlin-interview-questions/",
		"answer": "<p>There are broadly two types of variables in Kotlin. They are as follows:-</p><ul><li><strong>val </strong>(<strong>Immutable Variables</strong>)</li><li><strong>var </strong>(<strong>Mutable Variables</strong>)</li></ul><p><strong>Immutable Variables</strong>&nbsp;&mdash; Immutable variables are also known as read-only variables. They are declared using the val keyword. Once these variables have been declared, we cannot change their values.</p><p>The&nbsp;<strong>syntax</strong>&nbsp;is as follows :</p><blockquote><p><strong><em>val variableName=value</em></strong></p></blockquote><p>Example:</p><p><em>val str=&quot;Hello World&quot;</em></p><p><em>str=&quot;Hello again&quot;&nbsp; // this will show compile time error because val str can not be modified again once declare.</em></p><p>&nbsp;</p><p><strong>Mutable Variables</strong>&nbsp;- In a mutable variable, the value of the variable can be changed. We use the keyword &ldquo;var&rdquo; to declare such variables.</p><p>The&nbsp;<strong>syntax</strong>&nbsp;is as follows :</p><blockquote><p><strong><em>var variableName=value</em></strong></p></blockquote><p>Example:</p><p><em>var str=&quot;Hello World&quot;</em></p><p><em>str=&quot;Hello again&quot;&nbsp; // this will set the value of str to &quot;Hello again&quot; without any error.</em></p><p>&nbsp;</p>"
	}, {
		"id": 80,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "What are data classes in Kotlin? Explain with a proper example.",
		"referenceLink": "https://www.interviewbit.com/kotlin-interview-questions/",
		"answer": "<p>The Data class is a simple class that holds data and provides typical functions. To declare a class as a data class, use the data keyword.&nbsp;</p><p><strong>Syntax:</strong></p><blockquote><p><strong>data class className ( list_of_parameters)</strong></p></blockquote><p>The following functions are automatically derived by the compiler for the data classes:</p><ul><li><strong>equals()&nbsp;</strong>- The equals() function returns true if two objects have the identical contents. It operates similarly to &quot;==,&quot; although for Float and Double values it works differently.</li><li><strong>hashCode()&nbsp;</strong>- The hashCode() function returns the object&#39;s hashcode value.</li><li><strong>copy()</strong>&nbsp;- The copy() function is used to duplicate an object, changing only a few of its characteristics while leaving the rest unaltered.</li><li><strong>toString()</strong>&nbsp;- This function returns a string containing all of the data class&#39;s parameters.</li></ul><p style='margin-left:40px'>To ensure consistency, data classes must meet the following requirements:</p><ul><li>At least one parameter is required for the primary constructor.</li><li>val or var must be used for all primary constructor parameters.</li><li>Abstract, open, sealed, or inner data classes are not possible.</li><li>Only interfaces may be implemented by data classes.</li></ul><p><strong>Example:</strong></p><blockquote><p><strong>data class Sample(var input1 : Int, var input2 : Int)</strong></p></blockquote>"
	}, {
		"id": 81,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "What are Infix functions in Kotlin?",
		"referenceLink": "https://www.geeksforgeeks.org/kotlin-infix-function-notation/",
		"answer": "<p><strong>Infix functions:</strong></p><p>In Kotlin, a functions marked with&nbsp;<strong>infix</strong>&nbsp;keyword can also be called using infix notation means calling without using parenthesis and dot.&nbsp;<br/>There are&nbsp;<strong>two</strong>&nbsp;types of infix function notation in Kotlin-&nbsp;<br/>&nbsp;</p><ol><li>Standard library infix function notation</li><li>User defined infix function notation</li></ol><p><strong>Standard library infix function notation &ndash;</strong></p><p>When we call operators like and, or , shr, shl etc then compiler looks for the function and calls the desired one.</p><blockquote><p style='margin-left:40px'><br/>fun main(args: Array&lt;String&gt;){<br/>&nbsp; &nbsp; var a=15<br/>&nbsp; &nbsp; var b=12<br/>&nbsp; &nbsp; var c=11<br/>&nbsp; &nbsp; // call using dot and parenthesis<br/>&nbsp; &nbsp; var result1=(a &gt; b).and(a &gt; c) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br/>&nbsp; &nbsp; println(&quot;Boolean result1=$result1&quot;)<br/>&nbsp; &nbsp; // call using infix notation<br/>&nbsp; &nbsp; var result2=(a &gt; b) and (a &gt; c) &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br/>&nbsp; &nbsp; println(&quot;Boolean result1=$result2&quot;)<br/>}</p></blockquote><p style='margin-left:40px'>&nbsp;</p><p style='margin-left:40px'>&nbsp;</p><p><strong>User defined infix function notation &ndash;</strong><br/>We can create own function with infix notation if the function satisfy the following requirements:&nbsp;<br/>&nbsp;</p><ul><li>It must be member function or extension function</li><li>It must accepts a single parameter</li><li>The parameter must not accept variable number of arguments and must have no default value</li><li>It must be marked with infix keyword</li></ul><p>Kotlin program of creating square function with infix notation &ndash;</p><blockquote><p style='margin-left:40px'>class math{<br/>&nbsp; &nbsp; // user defined infix member function<br/>&nbsp; &nbsp; infix fun square(n : Int): Int{<br/>&nbsp; &nbsp; &nbsp; &nbsp; val num=n * n<br/>&nbsp; &nbsp; &nbsp; &nbsp; return num<br/>&nbsp; &nbsp;}<br/>}<br/>fun main(args: Array&lt;String&gt;){<br/>&nbsp; &nbsp;val m=math()<br/>&nbsp; &nbsp; // call using infix notation<br/>&nbsp; &nbsp; val result=m square 3<br/>&nbsp; &nbsp; print(&quot;The square of a number is: &quot;+result)<br/>}</p></blockquote><p style='margin-left:40px'>&nbsp;</p>"
	}, {
		"id": 82,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "What are Inline functions in Kotlin?",
		"referenceLink": "https://www.geeksforgeeks.org/kotlin-inline-functions/",
		"answer": "<p><strong>Inline Functions:</strong></p><p style='margin-left:40px'>In Kotlin, the higher-order functions or lambda expressions, all stored as an&nbsp;<strong>object</strong>&nbsp;so memory allocation, for both function objects and classes, and virtual calls might introduce runtime overhead. Sometimes we can eliminate the memory overhead by inlining the lambda expression.&nbsp;In order to reduce the memory overhead of such higher-order functions or lambda expressions, we can use the&nbsp;<strong>inline</strong>&nbsp;keyword which ultimately requests the compiler to not allocate memory and simply copy the inlined code of that function at the calling place.</p><p style='margin-left:40px'>It should be only used with small function,</p>"
	}, {
		"id": 83,
		"category": "kotlin",
		"subType": "kotlin",
		"question": "What are the scope functions in Kotlin?",
		"referenceLink": "https://www.geeksforgeeks.org/kotlin-scope-function/",
		"answer": "<p>There are several functions in the Kotlin standard library that help in the execution of a block of code within the context of an object. Calling these functions on an object with lambda expression creates a temporary scope. These functions are called&nbsp;<strong>Scope Functions</strong>. We can access the object of these functions without its name.</p><p>There are five of them:&nbsp;<strong><code>let</code>,&nbsp;<code>run</code>,&nbsp;<code>with</code>,&nbsp;<code>apply</code>,</strong> and&nbsp;<strong><code>also</code></strong>.</p><p>Example (without scope function):</p><blockquote><p>val alice=Person(&quot;Alice&quot;, 20, &quot;Amsterdam&quot;)<br/>println(alice)<br/>alice.moveTo(&quot;London&quot;)<br/>alice.incrementAge()<br/>println(alice)</p></blockquote><p>with scope function (using let):</p><blockquote><p>Person(&quot;Alice&quot;, 20, &quot;Amsterdam&quot;).let{<br/>&nbsp; &nbsp; println(it)<br/>&nbsp; &nbsp; it.moveTo(&quot;London&quot;)<br/>&nbsp; &nbsp; it.incrementAge()<br/>&nbsp; &nbsp; println(it)<br/>}</p></blockquote><h5>Explanation:</h5><p>You must have noticed that when we are not using the scope function, we need to write the object name every time to refer to members of the class. While using the scope function, we can directly refer to members without the object name. This is one of the ways of using the scope function.</p><p><strong>Differences in these functions:</strong></p><p>There are mainly two differences among these functions:</p><ol><li><strong>&nbsp;Way of referring to a context object</strong>&nbsp;(i.e. using either &lsquo;this&rsquo; or &lsquo;it&rsquo; keyword)</li><li><strong>&nbsp;return value</strong>&nbsp;(i.e. returns either &lsquo;context object&rsquo; or &lsquo;lambda result&rsquo;)</li></ol><p>&nbsp;</p><p><strong>1. let:</strong></p><p>Object reference: <strong>it</strong></p><p>Return value: <strong>Lambda result</strong></p><p>Use case:&nbsp;let function is often used to provide null safety calls. Use&nbsp;<strong>safe call operator(?.)</strong>&nbsp;with &lsquo;let&rsquo; for null safety. It executes the block only with the non-null value.</p><p>Example:&nbsp;</p><blockquote><p>fun main(){<br/>&nbsp; &nbsp; var a: Int?=null<br/>&nbsp;&nbsp; &nbsp;// using let function<br/>&nbsp;&nbsp; &nbsp;a?.let{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// statement(s) will not execute as a is null<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(it)<br/>&nbsp;&nbsp; &nbsp;}<br/>&nbsp;&nbsp; &nbsp;// re-initializing value of a to 2<br/>&nbsp;&nbsp; &nbsp;a=2<br/>&nbsp;&nbsp; &nbsp;a?.let{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// statement(s) will execute as a is not null<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(a)<br/>&nbsp;&nbsp; &nbsp;}<br/>}</p></blockquote><p><strong>2. run:</strong></p><p>Object reference: <strong>this</strong></p><p>Return value: <strong>Lambda result</strong></p><p>Use case:&nbsp;Used when the object lambda contains both initialization and the computation of the return value. &nbsp;Using run we can perform null safety calls as well as other computations.</p><p>Example:&nbsp;</p><blockquote><p>class Company(){<br/>&nbsp;&nbsp; &nbsp;lateinit var name: String<br/>&nbsp;&nbsp; &nbsp;lateinit var objective: String<br/>}</p><p>fun main(args: Array&lt;String&gt;){<br/>&nbsp;&nbsp; &nbsp;println(&quot;Company Name : &quot;)<br/>&nbsp;&nbsp; &nbsp;var company: Company?=null</p><p>&nbsp;&nbsp; &nbsp;// body only executes if company is non-null<br/>&nbsp;&nbsp; &nbsp;company?.run{&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(name)<br/>&nbsp;&nbsp; &nbsp;}</p><p>&nbsp;&nbsp; &nbsp;print(&quot;Company Name : &quot;)<br/>&nbsp;&nbsp; &nbsp;// re-initialize company<br/>&nbsp;&nbsp; &nbsp;company=Company().apply{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name=&quot;Techmaster&quot;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;objective=&quot;A learning platform&quot;<br/>&nbsp;&nbsp; &nbsp;}<br/>&nbsp;&nbsp; &nbsp;// body executes as &#39;company&#39; is non-null<br/>&nbsp;&nbsp; &nbsp;company?.run{&nbsp;&nbsp; &nbsp;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print(name)<br/>&nbsp;&nbsp; &nbsp;}<br/>}</p></blockquote><p><strong>3. with:</strong></p><p>Object reference: <strong>this</strong></p><p>Return value: <strong>Lambda result</strong></p><p>Use case:&nbsp;Recommended use of &lsquo;with&rsquo; for calling functions on context objects without providing the lambda result.</p><p>Example:&nbsp;</p><blockquote><p>class Company(){<br/>&nbsp;&nbsp; &nbsp;lateinit var name: String<br/>&nbsp;&nbsp; &nbsp;lateinit var objective: String<br/>}</p><p>fun main(){<br/>&nbsp;&nbsp; &nbsp;val gfg=Company().apply{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name=&quot;Techmaster&quot;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;objective=&quot;A learning platform&quot;<br/>&nbsp;&nbsp; &nbsp;}</p><p>&nbsp;&nbsp; &nbsp;// with function<br/>&nbsp;&nbsp; &nbsp;with(gfg){<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// similar to println( &quot;${this.name}&quot; )<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;println(&quot; $name &quot;)<br/>&nbsp;&nbsp; &nbsp;}<br/>}</p></blockquote><p><strong>4. apply:</strong></p><p>Object reference: <strong>this</strong></p><p>Return value: <strong>context object</strong></p><p>Use case:&nbsp;As the name implies &ndash; &ldquo;Apply these to the object&rdquo;. It can be used to operate on members of the receiver object mostly to initialize members.</p><p>Example:&nbsp;</p><blockquote><p>class Company(){<br/>&nbsp;&nbsp; &nbsp;lateinit var name: String<br/>&nbsp;&nbsp; &nbsp;lateinit var objective: String<br/>}</p><p>fun main(){<br/>&nbsp;&nbsp; &nbsp;Company().apply{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// same as name=&ldquo;Thecmaster&rdquo;<br/>&nbsp; &nbsp; &nbsp; &nbsp; this.name=&quot;Thecmaster&quot;<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;objective=&quot;A learning platform&quot;<br/>&nbsp;&nbsp; &nbsp;}<br/>}</p></blockquote><p><strong>5. also:</strong></p><p>Object reference: <strong>it</strong></p><p>Return value: <strong>context object</strong></p><p>Use case:&nbsp;It is used where we have to perform additional operations when we have initialized the object members.</p><p>Example:&nbsp;</p><blockquote><p>fun main(){<br/>&nbsp;&nbsp; &nbsp;// initialized<br/>&nbsp;&nbsp; &nbsp;val list=mutableListOf&lt;Int&gt;(1, 2, 3)</p><p>&nbsp;&nbsp; &nbsp;// later if we want to perform<br/>&nbsp;&nbsp; &nbsp;// multiple operations on this list<br/>&nbsp;&nbsp; &nbsp;list.also{<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;it.add(4)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;it.remove(2)<br/>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// more operations if needed<br/>&nbsp;&nbsp; &nbsp;}<br/>&nbsp;&nbsp; &nbsp;println(list)<br/>}<br/>output: [1, 3, 4]</p></blockquote><h5><strong>Summary:</strong></h5><ul><li>&nbsp;Scope functions make code more readable, clear and concise.</li><li>&nbsp;Object reference &ndash; &lsquo;this&rsquo; and &lsquo;it&rsquo;.</li><li>&nbsp;Return value &ndash; context object and lambda result.</li><li>&nbsp;let : working with nullable objects to avoid NullPointerException.</li><li>&nbsp;apply : changing object configuration.</li><li>&nbsp;run: operate on nullable object, executing lambda expressions.</li><li>&nbsp;also : adding additional operations.</li><li>&nbsp;with : operating on non-null objects.</li></ul>"
	}]
}
